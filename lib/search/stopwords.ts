// Stopwords for search query preprocessing.
// Focused on words that are noise in a development/programming context.
// Technical terms (function, type, class, etc.) are intentionally excluded.

const ENGLISH_STOPWORDS = new Set([
  // Articles & determiners
  "the",
  "this",
  "that",
  "these",
  "those",
  "some",
  "any",
  "all",
  "each",
  "every",
  "both",
  "other",
  // Pronouns
  "you",
  "your",
  "its",
  "his",
  "her",
  "our",
  "their",
  "them",
  "they",
  "who",
  "whom",
  "which",
  // Prepositions & conjunctions
  "for",
  "with",
  "from",
  "into",
  "about",
  "between",
  "through",
  "during",
  "before",
  "after",
  "above",
  "below",
  "under",
  "and",
  "but",
  "nor",
  "not",
  "than",
  "then",
  "also",
  "once",
  "again",
  "further",
  "such",
  "same",
  "few",
  "more",
  "most",
  "too",
  "own",
  // Common verbs (non-technical)
  "are",
  "was",
  "were",
  "been",
  "being",
  "have",
  "has",
  "had",
  "does",
  "did",
  "will",
  "would",
  "could",
  "should",
  "shall",
  "might",
  "must",
  "can",
  // Prompt noise
  "please",
  "help",
  "want",
  "need",
  "like",
  "just",
  "only",
  "very",
  "really",
  "here",
  "there",
  "what",
  "when",
  "where",
  "how",
  "why",
  "let",
  "make",
  "way",
  "tell",
]);

const JAPANESE_STOPWORDS = new Set([
  // Common prompt phrases (split on whitespace, so these appear as tokens)
  "ください",
  "について",
  "ついて",
  "します",
  "している",
  "してる",
  "できる",
  "できます",
  "ですか",
  "ありますか",
  "ありません",
  "ありました",
  "ですが",
  "ですけど",
  "ですので",
  "ですから",
  "ですね",
  "ですよ",
  "しましょう",
  "しよう",
  "したい",
  "したいです",
  "ほしい",
  "ほしいです",
  "ありがとう",
  "おねがい",
  "お願い",
  "教えて",
  "見せて",
  "やって",
  "どうやって",
  "なぜ",
  "どう",
  "どの",
  "その",
  "この",
  "あの",
  "それ",
  "これ",
  "あれ",
]);

const ALL_STOPWORDS = new Set([...ENGLISH_STOPWORDS, ...JAPANESE_STOPWORDS]);

export function isStopword(token: string): boolean {
  return ALL_STOPWORDS.has(token.toLowerCase());
}

export function removeStopwords(tokens: string[]): string[] {
  const filtered = tokens.filter((t) => !isStopword(t));
  // If all tokens are stopwords, keep the original to avoid empty search
  return filtered.length > 0 ? filtered : tokens;
}
